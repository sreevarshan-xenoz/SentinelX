# SentinelX Alert Manager

import json
import time
from typing import Dict, List, Any, Optional, Union, Callable
import logging
import os
from datetime import datetime
import uuid
import requests
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

from ..core.config_manager import ConfigManager
from .threat_enricher import ThreatEnricher

class Alert:
    """Alert class for SentinelX.
    
    This class represents a security alert generated by the system.
    """
    
    def __init__(self, alert_id: str, alert_type: str, severity: str, 
                source: str, timestamp: str, details: Dict[str, Any]):
        """Initialize an alert.
        
        Args:
            alert_id: Unique identifier for the alert
            alert_type: Type of alert (e.g., 'intrusion', 'anomaly')
            severity: Severity level (e.g., 'low', 'medium', 'high')
            source: Source of the alert (e.g., 'model', 'rule')
            timestamp: ISO format timestamp
            details: Dictionary containing alert details
        """
        self.alert_id = alert_id
        self.alert_type = alert_type
        self.severity = severity
        self.source = source
        self.timestamp = timestamp
        self.details = details
        self.enrichment: Optional[Dict[str, Any]] = None
        self.status = "new"  # new, acknowledged, resolved, false_positive
        self.assigned_to: Optional[str] = None
        self.resolution_notes: Optional[str] = None
        self.resolution_timestamp: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert alert to dictionary.
        
        Returns:
            Dictionary representation of the alert
        """
        return {
            'alert_id': self.alert_id,
            'alert_type': self.alert_type,
            'severity': self.severity,
            'source': self.source,
            'timestamp': self.timestamp,
            'details': self.details,
            'enrichment': self.enrichment,
            'status': self.status,
            'assigned_to': self.assigned_to,
            'resolution_notes': self.resolution_notes,
            'resolution_timestamp': self.resolution_timestamp
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Alert':
        """Create an alert from a dictionary.
        
        Args:
            data: Dictionary containing alert data
            
        Returns:
            Alert instance
        """
        alert = cls(
            alert_id=data['alert_id'],
            alert_type=data['alert_type'],
            severity=data['severity'],
            source=data['source'],
            timestamp=data['timestamp'],
            details=data['details']
        )
        
        alert.enrichment = data.get('enrichment')
        alert.status = data.get('status', 'new')
        alert.assigned_to = data.get('assigned_to')
        alert.resolution_notes = data.get('resolution_notes')
        alert.resolution_timestamp = data.get('resolution_timestamp')
        
        return alert


class AlertManager:
    """Alert manager for SentinelX.
    
    This class is responsible for generating, storing, and managing alerts
    based on detected threats and enrichment data.
    """
    
    def __init__(self):
        """Initialize the alert manager."""
        self.config = ConfigManager()
        self.logger = logging.getLogger(__name__)
        
        # Initialize threat enricher
        self.enricher = ThreatEnricher()
        
        # Get alert configuration
        self.thresholds = self.config.get('alerts', 'threshold', {
            'low': 0.5,
            'medium': 0.7,
            'high': 0.9
        })
        
        # Get notification configuration
        self.notification_config = self.config.get('alerts', 'notification', {})
        
        # Get auto response configuration
        self.auto_response_config = self.config.get('auto_response', {})
        
        # Initialize alerts storage
        self.alerts: List[Alert] = []
        
        # Get data directory from config
        data_dir = self.config.get('paths', 'data_dir', '../data')
        
        # Get the directory of the current file
        current_dir = os.path.dirname(os.path.abspath(__file__))
        # Navigate to the data directory
        self.data_dir = os.path.abspath(os.path.join(current_dir, '..', '..', data_dir))
        
        # Alerts file path
        self.alerts_dir = os.path.join(self.data_dir, 'alerts')
        if not os.path.exists(self.alerts_dir):
            os.makedirs(self.alerts_dir)
        
        self.alerts_file = os.path.join(self.alerts_dir, 'alerts.json')
        
        # Load existing alerts
        self.load_alerts()
        
        self.logger.info(f"Alert manager initialized with {len(self.alerts)} existing alerts")
    
    def create_alert(self, alert_type: str, details: Dict[str, Any], 
                    source: str = 'model', enrich: bool = True) -> Alert:
        """Create a new alert.
        
        Args:
            alert_type: Type of alert (e.g., 'intrusion', 'anomaly')
            details: Dictionary containing alert details
            source: Source of the alert (e.g., 'model', 'rule')
            enrich: Whether to enrich the alert with threat intelligence
            
        Returns:
            The created alert
        """
        # Generate alert ID
        alert_id = str(uuid.uuid4())
        
        # Determine severity based on confidence/probability
        confidence = details.get('confidence', 0.0)
        severity = self._determine_severity(confidence)
        
        # Create timestamp
        timestamp = datetime.now().isoformat()
        
        # Create alert
        alert = Alert(
            alert_id=alert_id,
            alert_type=alert_type,
            severity=severity,
            source=source,
            timestamp=timestamp,
            details=details
        )
        
        # Enrich alert if requested
        if enrich:
            self._enrich_alert(alert)
        
        # Add to alerts list
        self.alerts.append(alert)
        
        # Save alerts
        self.save_alerts()
        
        # Log alert creation
        self.logger.info(f"Created {severity} severity {alert_type} alert: {alert_id}")
        
        # Send notifications
        self._send_notifications(alert)
        
        # Perform auto response actions
        self._auto_respond(alert)
        
        return alert
    
    def get_alert(self, alert_id: str) -> Optional[Alert]:
        """Get an alert by ID.
        
        Args:
            alert_id: The alert ID to retrieve
            
        Returns:
            The alert if found, None otherwise
        """
        for alert in self.alerts:
            if alert.alert_id == alert_id:
                return alert
        return None
    
    def update_alert(self, alert_id: str, **kwargs) -> Optional[Alert]:
        """Update an existing alert.
        
        Args:
            alert_id: The alert ID to update
            **kwargs: Fields to update
            
        Returns:
            The updated alert if found, None otherwise
        """
        alert = self.get_alert(alert_id)
        if not alert:
            self.logger.warning(f"Alert not found: {alert_id}")
            return None
        
        # Update fields
        for key, value in kwargs.items():
            if hasattr(alert, key):
                setattr(alert, key, value)
        
        # Save alerts
        self.save_alerts()
        
        self.logger.info(f"Updated alert: {alert_id}")
        return alert
    
    def resolve_alert(self, alert_id: str, resolution_notes: Optional[str] = None, 
                     status: str = "resolved") -> Optional[Alert]:
        """Resolve an alert.
        
        Args:
            alert_id: The alert ID to resolve
            resolution_notes: Notes about the resolution
            status: New status (resolved, false_positive)
            
        Returns:
            The updated alert if found, None otherwise
        """
        alert = self.get_alert(alert_id)
        if not alert:
            self.logger.warning(f"Alert not found: {alert_id}")
            return None
        
        # Update alert
        alert.status = status
        alert.resolution_notes = resolution_notes
        alert.resolution_timestamp = datetime.now().isoformat()
        
        # Save alerts
        self.save_alerts()
        
        self.logger.info(f"Resolved alert {alert_id} with status: {status}")
        return alert
    
    def get_alerts(self, filters: Optional[Dict[str, Any]] = None, 
                  limit: Optional[int] = None, 
                  sort_by: str = "timestamp", 
                  sort_desc: bool = True) -> List[Alert]:
        """Get alerts with optional filtering and sorting.
        
        Args:
            filters: Dictionary of field-value pairs to filter by
            limit: Maximum number of alerts to return
            sort_by: Field to sort by
            sort_desc: Whether to sort in descending order
            
        Returns:
            List of matching alerts
        """
        # Start with all alerts
        result = self.alerts.copy()
        
        # Apply filters
        if filters:
            for key, value in filters.items():
                result = [alert for alert in result 
                         if hasattr(alert, key) and getattr(alert, key) == value]
        
        # Sort results
        if sort_by == "timestamp":
            result.sort(key=lambda x: x.timestamp, reverse=sort_desc)
        elif sort_by == "severity":
            # Custom sort order for severity
            severity_order = {"low": 0, "medium": 1, "high": 2}
            result.sort(key=lambda x: severity_order.get(x.severity, 0), reverse=sort_desc)
        elif hasattr(Alert, sort_by):
            result.sort(key=lambda x: getattr(x, sort_by), reverse=sort_desc)
        
        # Apply limit
        if limit is not None and limit > 0:
            result = result[:limit]
        
        return result
    
    def save_alerts(self) -> bool:
        """Save alerts to disk.
        
        Returns:
            True if successful, False otherwise
        """
        try:
            # Convert alerts to dictionaries
            alerts_data = [alert.to_dict() for alert in self.alerts]
            
            # Write to file
            with open(self.alerts_file, 'w') as f:
                json.dump(alerts_data, f, indent=2)
            
            self.logger.debug(f"Saved {len(self.alerts)} alerts to {self.alerts_file}")
            return True
        except Exception as e:
            self.logger.error(f"Error saving alerts: {str(e)}")
            return False
    
    def load_alerts(self) -> bool:
        """Load alerts from disk.
        
        Returns:
            True if successful, False otherwise
        """
        if not os.path.exists(self.alerts_file):
            self.logger.info(f"Alerts file not found: {self.alerts_file}")
            return False
        
        try:
            with open(self.alerts_file, 'r') as f:
                alerts_data = json.load(f)
            
            # Convert dictionaries to Alert objects
            self.alerts = [Alert.from_dict(data) for data in alerts_data]
            
            self.logger.info(f"Loaded {len(self.alerts)} alerts from {self.alerts_file}")
            return True
        except Exception as e:
            self.logger.error(f"Error loading alerts: {str(e)}")
            return False
    
    def _determine_severity(self, confidence: float) -> str:
        """Determine alert severity based on confidence score.
        
        Args:
            confidence: Confidence score (0.0 to 1.0)
            
        Returns:
            Severity level (low, medium, high)
        """
        if confidence >= self.thresholds.get('high', 0.9):
            return "high"
        elif confidence >= self.thresholds.get('medium', 0.7):
            return "medium"
        elif confidence >= self.thresholds.get('low', 0.5):
            return "low"
        else:
            return "info"
    
    def _enrich_alert(self, alert: Alert) -> None:
        """Enrich an alert with threat intelligence data.
        
        Args:
            alert: The alert to enrich
        """
        enrichment_data = {}
        
        # Check for IP addresses in the alert details
        ip_address = alert.details.get('src_ip') or alert.details.get('dst_ip')
        if ip_address:
            try:
                ip_data = self.enricher.enrich_ip(ip_address)
                enrichment_data['ip'] = ip_data
            except Exception as e:
                self.logger.error(f"Error enriching IP {ip_address}: {str(e)}")
        
        # Check for domains in the alert details
        domain = alert.details.get('domain') or alert.details.get('hostname')
        if domain:
            try:
                domain_data = self.enricher.enrich_domain(domain)
                enrichment_data['domain'] = domain_data
            except Exception as e:
                self.logger.error(f"Error enriching domain {domain}: {str(e)}")
        
        # Set enrichment data on the alert
        if enrichment_data:
            alert.enrichment = enrichment_data
            self.logger.debug(f"Enriched alert {alert.alert_id} with threat intelligence data")
    
    def _send_notifications(self, alert: Alert) -> None:
        """Send notifications for an alert.
        
        Args:
            alert: The alert to send notifications for
        """
        # Only send notifications for medium and high severity alerts by default
        if alert.severity not in ['medium', 'high']:
            return
        
        # Email notifications
        email_config = self.notification_config.get('email', {})
        if email_config.get('enabled', False):
            try:
                self._send_email_notification(alert, email_config)
            except Exception as e:
                self.logger.error(f"Error sending email notification: {str(e)}")
        
        # Webhook notifications
        webhook_config = self.notification_config.get('webhook', {})
        if webhook_config.get('enabled', False):
            try:
                self._send_webhook_notification(alert, webhook_config)
            except Exception as e:
                self.logger.error(f"Error sending webhook notification: {str(e)}")
        
        # Discord notifications
        discord_config = self.notification_config.get('discord', {})
        if discord_config.get('enabled', False):
            try:
                self._send_discord_notification(alert, discord_config)
            except Exception as e:
                self.logger.error(f"Error sending Discord notification: {str(e)}")
    
    def _send_email_notification(self, alert: Alert, config: Dict[str, Any]) -> None:
        """Send an email notification for an alert.
        
        Args:
            alert: The alert to send notification for
            config: Email notification configuration
        """
        smtp_server = config.get('smtp_server')
        smtp_port = config.get('smtp_port', 587)
        sender = config.get('sender')
        recipients = config.get('recipients', [])
        
        if not smtp_server or not sender or not recipients:
            self.logger.warning("Email notification configuration incomplete")
            return
        
        # Create message
        msg = MIMEMultipart()
        msg['From'] = sender
        msg['To'] = ", ".join(recipients)
        msg['Subject'] = f"SentinelX Alert: {alert.severity.upper()} - {alert.alert_type}"
        
        # Create message body
        body = f"""SentinelX Security Alert

Alert ID: {alert.alert_id}
Type: {alert.alert_type}
Severity: {alert.severity.upper()}
Timestamp: {alert.timestamp}

Details:
{json.dumps(alert.details, indent=2)}

"""
        
        # Add enrichment data if available
        if alert.enrichment:
            body += f"Enrichment Data:\n{json.dumps(alert.enrichment, indent=2)}\n\n"
        
        msg.attach(MIMEText(body, 'plain'))
        
        # Send email
        try:
            server = smtplib.SMTP(smtp_server, smtp_port)
            server.starttls()
            
            # If username/password are provided, login
            username = config.get('username')
            password = config.get('password')
            if username and password:
                server.login(username, password)
            
            server.send_message(msg)
            server.quit()
            
            self.logger.info(f"Sent email notification for alert {alert.alert_id} to {len(recipients)} recipients")
        except Exception as e:
            self.logger.error(f"Error sending email: {str(e)}")
            raise
    
    def _send_webhook_notification(self, alert: Alert, config: Dict[str, Any]) -> None:
        """Send a webhook notification for an alert.
        
        Args:
            alert: The alert to send notification for
            config: Webhook notification configuration
        """
        webhook_url = config.get('url')
        
        if not webhook_url:
            self.logger.warning("Webhook URL not configured")
            return
        
        # Create payload
        payload = {
            'alert': alert.to_dict()
        }
        
        # Send webhook
        response = requests.post(
            webhook_url,
            json=payload,
            headers={'Content-Type': 'application/json'}
        )
        
        if response.status_code >= 200 and response.status_code < 300:
            self.logger.info(f"Sent webhook notification for alert {alert.alert_id}")
        else:
            self.logger.error(f"Error sending webhook: {response.status_code} - {response.text}")
            raise Exception(f"Webhook error: {response.status_code}")
    
    def _send_discord_notification(self, alert: Alert, config: Dict[str, Any]) -> None:
        """Send a Discord notification for an alert.
        
        Args:
            alert: The alert to send notification for
            config: Discord notification configuration
        """
        webhook_url = config.get('webhook_url')
        
        if not webhook_url:
            self.logger.warning("Discord webhook URL not configured")
            return
        
        # Set color based on severity
        color_map = {
            'low': 0x00FF00,  # Green
            'medium': 0xFFFF00,  # Yellow
            'high': 0xFF0000,   # Red
            'info': 0x0000FF    # Blue
        }
        color = color_map.get(alert.severity, 0x808080)  # Default gray
        
        # Create embed
        embed = {
            'title': f"SentinelX Alert: {alert.alert_type}",
            'description': f"A {alert.severity} severity alert has been detected.",
            'color': color,
            'fields': [
                {'name': 'Alert ID', 'value': alert.alert_id, 'inline': True},
                {'name': 'Severity', 'value': alert.severity.upper(), 'inline': True},
                {'name': 'Source', 'value': alert.source, 'inline': True},
                {'name': 'Timestamp', 'value': alert.timestamp, 'inline': False},
            ],
            'footer': {'text': 'SentinelX Security Alert System'}
        }
        
        # Add details fields
        for key, value in alert.details.items():
            if isinstance(value, (str, int, float, bool)):
                embed['fields'].append({
                    'name': key,
                    'value': str(value),
                    'inline': True
                })
        
        # Add enrichment summary if available
        if alert.enrichment:
            enrichment_summary = []
            
            # IP enrichment
            if 'ip' in alert.enrichment:
                ip_data = alert.enrichment['ip']
                if ip_data.get('malicious', False):
                    enrichment_summary.append(f"IP {ip_data.get('ip', 'unknown')} is flagged as malicious")
                    
                    # Add threat types if available
                    threat_types = ip_data.get('sources', {}).get('AlienVault OTX', {}).get('threat_types', [])
                    if threat_types:
                        enrichment_summary.append(f"Threat types: {', '.join(threat_types[:3])}")
            
            # Domain enrichment
            if 'domain' in alert.enrichment:
                domain_data = alert.enrichment['domain']
                if domain_data.get('malicious', False):
                    enrichment_summary.append(f"Domain {domain_data.get('domain', 'unknown')} is flagged as malicious")
            
            if enrichment_summary:
                embed['fields'].append({
                    'name': 'Threat Intelligence',
                    'value': '\n'.join(enrichment_summary),
                    'inline': False
                })
        
        # Create payload
        payload = {
            'embeds': [embed]
        }
        
        # Send Discord webhook
        response = requests.post(
            webhook_url,
            json=payload,
            headers={'Content-Type': 'application/json'}
        )
        
        if response.status_code >= 200 and response.status_code < 300:
            self.logger.info(f"Sent Discord notification for alert {alert.alert_id}")
        else:
            self.logger.error(f"Error sending Discord webhook: {response.status_code} - {response.text}")
            raise Exception(f"Discord webhook error: {response.status_code}")
    
    def _auto_respond(self, alert: Alert) -> None:
        """Perform automated response actions for an alert.
        
        Args:
            alert: The alert to respond to
        """
        # Check if auto-response is enabled
        if not self.auto_response_config.get('enabled', False):
            return
        
        # Only auto-respond to high severity alerts by default
        if alert.severity != 'high':
            return
        
        actions = self.auto_response_config.get('actions', {})
        
        # Block IP action
        if actions.get('block_ip', {}).get('enabled', False):
            ip_address = alert.details.get('src_ip')
            if ip_address:
                try:
                    self._block_ip(ip_address, actions.get('block_ip', {}))
                except Exception as e:
                    self.logger.error(f"Error blocking IP {ip_address}: {str(e)}")
        
        # Log event action
        if actions.get('log_event', {}).get('enabled', False):
            try:
                self._log_security_event(alert)
            except Exception as e:
                self.logger.error(f"Error logging security event: {str(e)}")
        
        # Notify admin action
        if actions.get('notify_admin', {}).get('enabled', False):
            try:
                self._notify_admin(alert)
            except Exception as e:
                self.logger.error(f"Error notifying admin: {str(e)}")
    
    def _block_ip(self, ip_address: str, config: Dict[str, Any]) -> None:
        """Block an IP address.
        
        Args:
            ip_address: The IP address to block
            config: Block IP configuration
        """
        # This is a placeholder for actual IP blocking logic
        # In a real implementation, this would interface with firewall rules
        duration_minutes = config.get('duration_minutes', 60)
        
        self.logger.info(f"[AUTO-RESPONSE] Blocking IP {ip_address} for {duration_minutes} minutes")
        
        # Log the action in a special file
        blocked_ips_file = os.path.join(self.alerts_dir, 'blocked_ips.json')
        
        try:
            # Load existing blocked IPs
            blocked_ips = []
            if os.path.exists(blocked_ips_file):
                with open(blocked_ips_file, 'r') as f:
                    blocked_ips = json.load(f)
            
            # Add new blocked IP
            blocked_ips.append({
                'ip': ip_address,
                'timestamp': datetime.now().isoformat(),
                'duration_minutes': duration_minutes,
                'expires': (datetime.now() + timedelta(minutes=duration_minutes)).isoformat()
            })
            
            # Save blocked IPs
            with open(blocked_ips_file, 'w') as f:
                json.dump(blocked_ips, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving blocked IP: {str(e)}")
    
    def _log_security_event(self, alert: Alert) -> None:
        """Log a security event.
        
        Args:
            alert: The alert to log
        """
        # This is a placeholder for actual security event logging logic
        self.logger.info(f"[AUTO-RESPONSE] Logging security event for alert {alert.alert_id}")
        
        # Log the event in a special file
        security_events_file = os.path.join(self.alerts_dir, 'security_events.json')
        
        try:
            # Load existing security events
            security_events = []
            if os.path.exists(security_events_file):
                with open(security_events_file, 'r') as f:
                    security_events = json.load(f)
            
            # Add new security event
            security_events.append({
                'timestamp': datetime.now().isoformat(),
                'alert_id': alert.alert_id,
                'alert_type': alert.alert_type,
                'severity': alert.severity,
                'details': alert.details
            })
            
            # Save security events
            with open(security_events_file, 'w') as f:
                json.dump(security_events, f, indent=2)
        except Exception as e:
            self.logger.error(f"Error saving security event: {str(e)}")
    
    def _notify_admin(self, alert: Alert) -> None:
        """Notify admin about an alert.
        
        Args:
            alert: The alert to notify about
        """
        # This is a placeholder for actual admin notification logic
        self.logger.info(f"[AUTO-RESPONSE] Notifying admin about alert {alert.alert_id}")
        
        # In a real implementation, this could send a high-priority notification
        # through a different channel than regular notifications